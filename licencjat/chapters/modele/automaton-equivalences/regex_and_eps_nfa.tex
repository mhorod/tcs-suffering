    Ostatnia rzecz, którą chcemy uzyskać to sposób konwersji wyrażenia regularnego do \(\eps\)-NFA. To dałoby nam już wspaniały rezultat, bo mielibyśmy, że wyrażenia regularne i wymienione wyżej automaty są wzajemnie równoważne jeśli chodzi o ich ,,moc''. W tym celu możemy wykonać indukcję po długości wyrażenia regularnego, intuicyjnie konstruując nowy automat na podstawie ,,wcześniejszych''.
    
    Na początek wypada powiedzieć co robimy dla ,,trywialnych'' wyrażeń regularnych, by indukcja się spięła. Jeśli wyrażene jest postaci \(a\), dla \( a \in \Sigma\), tworzymy trywialnie automat który akceptuje jedynie słowo takiej postaci. Dla pustego wyrażenia tworzymy automat który nie akceptuje niczego, dla \(1\) tworzymy (równie trywialnie) automat który zaakceptuje jedynie \(\eps\). 
    
    Mając z głowy nudne przypadki bazowe, możemy przejść do ciekawszej rzeczy dowodu, czyli konwersji poszczególnych wyrażeń regularnych na automaty. Będziemy się kejsować po tym, na co jesteśmy w stanie ,,rozbić'' regex\footnote{czyli robimy indukcję strukturalną czy coś tam}: 
    \begin{itemize}
        \item Jeśli wyrażenie regularne jest postaci \( \alpha_1 + \alpha_2 \), to z założenia indukcyjnego mamy, że istnieją DFA \(A_1, A_2\) takie, że \(L(A_1) = L(\alpha_1)\) i \(L(A_2) = L(\alpha_2)\). Możemy stworzyć automat \(A_3\), który składa się z tych samych stanów i przejść co \(A_1\) i \(A_2\), ale ma jeszcze dodatkowy stan \(q\); \(q\) jest stanem startowym nowego automatu i ma epsilon przejścia do stanów startowych \(A_1\) i \(A_2\).  Zauważamy, że jeśli słowo należy do języka akceptowanego przez któryś z tych automatów (nazwijmy go \(A\)), to w automacie \(A_3\) istnieje obliczenie, które ze stanu startowego przechodzi epsilon-przejściem do stanu startowego \(A\), po czym to słowo zostanie zaakceptowane. Jeśli żaden z automatów nie akceptował tego słowa, to trywialnie widać że nowy automat również go nie zaakceptuje.
        \item Jeśli wyrażenie regularne jest postaci \( \alpha_1 \cdot \alpha_2 \), to, podobnie jak powyżej, musimy wymyślić jakiś sposób na zrobienie nowego automatu mając automaty \(A_1\) i \(A_2\) tak, by ten akceptował konkatenację tych języków. Ponownie więc tworzymy \(A_3\), który ma wszystkie stany i przejścia ze wspomnianych automatów wraz z nowym stanem startowym \(q\). Dodaję \(\eps\)-przejście z \(q\) do stanu startowego z \(A_1\) oraz \(\eps\)-przejścia ze stanów akceptujących \(A_1\) do stanu startowego \(A_2\). Stanami akceptującymi nowego automatu są \textbf{tylko} stany akceptujące z \(A_2\). Widać że to działa ładnie -- jeśli jakieś słowo \(w\) jest postaci \(xy\), gdzie \(x\in L(A_1)\) i \(y \in L(A_2)\), to istnieje obliczenie które ,,przejdzie'' \(x\) do stanu akceptującego, następnie ,,przeskoczy'' po epsilonie do \(A_2\), który z kolei zaakceptuje \(y\). Jeśli zaś słowo nie należy do konkatenacji takich języków, to znaczy że taki podział nie istnieje, a więc albo w ogóle nie ,,przejdziemy'' do \(A_2\), albo po przejściu do \(A_2\) nie zostaniemy zaakceptowani. 
        \item Jeśli wyrażenie regularne jest postaci \((\alpha)*\), to mamy jakiś automat \(A\), dla którego \(L(A) = L(\alpha)\). Chcemy teraz zrobić jakąś ,,owijkę'' na niego tak, by można było zaakceptować dowolne słowo będące ,,zlepkiem'' słów z tego języka (bo to gwiazdka kleenego). Konstrukcja jest całkiem oczywista: robimy automat \(B\), który, standardowo, ma wszystkie stany i przejścia z automatu \(A\). Dodajemy oddzielny stan startowy \(q\); dodajemy z niego \(\eps\)-przejście do stanu startowego \(A\). Dodajemy jeszcze \(\eps\)-przejścia ze stanów akceptujących \(A\) z powrotem do stanu \(q\). Stanem akceptującym również jest \(q\). Zauważmy, że jeśli jakieś słowo należy do języka generowanego przez \((\alpha)^*\), to istnieje jego podział na słowa które należą do \(L(\alpha)\), a więc istnieje obliczenie które będzie sobie akceptować po kolei te ,,podsłowa'', a na samym kończu się zakończy. Jednocześnie, cokolwiek co jest zaakceptowane przez \(B\) musi być takim ,,zlepkiem'', bo by ,,wrócić'' do \(q\) trzeba było przejść sekwencją przejść po literach stanowiących słowo matchujące wyrażenie regularne.
    \end{itemize}