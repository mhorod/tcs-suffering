Mamy podana liczbę $k$ oraz chcemy znaleść liczbę pierwszą $p$, która ma $k$ bitów, z czego wynika, że $p \in [2^k,2^{k+1}-1]$.
\newline \newline
Pierwszym faktem jaki zauważymy jest gęstość liczb pierwszych:\newline
W przedziale od 1 do n jest asymptotycznie $\bigO(\frac{n}{\log n})$ liczb pierwszych. 
\newline
Wynika z tego, że liczby pierwsze sa upakowane dosyć gęsto. Wiemy, że w przedziale od 1 do $2^{k+1} - 1$ jest rzędu $c\cdot \frac{2^{k+1}-1}{k+1}$ liczb pierwszych oraz w przedziale od 1 do $2^{k} - 1$ jest rzędu $c\cdot \frac{2^{k}-1}{k}$ wynika z tego, że w przedziale $[2^k,2^{k+1}-1]$ jest $c\cdot \frac{2^{k+1}-1}{k} - c\cdot \frac{2^{k}-1}{k}$ około tyle liczb pierwszych. Z czego wynika że mamy tam dalej $\bigO(\frac{n}{\log n})$ liczb pierwszych (troche machane).
\newline
\newline
Skoro są one upakowane dosyć gęsto to wykonajmy następującą procedurę.
\begin{itemize}
    \item Wylosuj $p$ z przedziału $[2^k,2^{k+1}-1]$.
    \item Za pomocą algorytmu Millera-Rabina sprawdź czy $p$ jest liczbą pierwszą
    \item Jeżeli jest pierwsza to ją zwróć, w przeciwnym wypadku powtórz procedurę.
\end{itemize}

Skoro wiemy, że w tym przedziale jest $\bigO(\frac{2^k}{k})$ liczb pierwszych to oznacza że w oczekiwaniu po $\bigO(k)$ losowaniach trafimy na liczbę pierwszą. Sprawdzanie z wolnym monożeniem czy liczba jest pierwsza z pomocą algorytmu Millera-Rabina wykonuje się w czasie $\bigO(k^3)$ czyli w oczekiwaniu otrzymujemy algorytm w złożoności $\bigO(k^4)$.